package eu.long1.flutter.i18n.workers

import com.intellij.json.psi.JsonFile
import com.intellij.json.psi.JsonProperty
import com.intellij.openapi.project.Project
import com.intellij.openapi.vfs.VirtualFile
import com.intellij.psi.PsiDocumentManager
import com.intellij.psi.PsiErrorElement
import com.intellij.psi.PsiFile
import com.intellij.psi.PsiManager
import com.intellij.psi.codeStyle.CodeStyleManager
import com.intellij.psi.util.PsiTreeUtil
import eu.long1.flutter.i18n.arb.ArbFileType
import eu.long1.flutter.i18n.files.FileHelpers
import java.util.regex.Pattern


class I18nFileGenerator(private val project: Project) {

    private val psiManager = PsiManager.getInstance(project)
    private val documentManager = PsiDocumentManager.getInstance(project)
    private val valuesFolder = FileHelpers.getValuesFolder(project)

    fun generate() {
        val files = stringFiles()
        if (files.isEmpty()) files.add(createFileForLang("en"))

        val data = HashMap<String, HashMap<String, String>>()

        files.forEach {
            val lang = it.nameWithoutExtension.substringAfter("_")
            val json = psiManager.findFile(it) as JsonFile
            data[lang] = getStringFromFile(json) ?: HashMap()
        }

        val builder = StringBuilder()
        builder.append(i18nFileImports)
        builder.append("// ignore_for_file: non_constant_identifier_names\n// ignore_for_file: camel_case_types\n// ignore_for_file: prefer_single_quotes\n\n")
        builder.append("//This file is automatically generated. DO NOT EDIT, all your changes would be lost.\n")
        appendSClass(data["en"]!!, builder)

        data.keys.forEach {
            if (it == "en") builder.append("class en extends S {\n  const en();\n}\n\n")
            else appendLangClass(it, data, builder)
        }

        appendDelegateClass(data, builder)

        val i18nFile = builder.toString()

        val file = FileHelpers.getI18nFile(project)
        val dartFile = psiManager.findFile(file)!!
        val document = documentManager.getDocument(dartFile)!!

        if (document.text != i18nFile) {
            document.setText(i18nFile)
            documentManager.commitDocument(document)
        }
    }

    private fun stringFiles(): ArrayList<VirtualFile> = valuesFolder.children.filter {
        it.extension == ArbFileType.defaultExtension && it.name.startsWith("strings_", true)
    } as ArrayList

    private fun appendSClass(en: HashMap<String, String>, builder: StringBuilder) {
        val ids = ArrayList<String>(en.keys)

        val pluralsMaps = HashMap<String, ArrayList<String>>()
        val plurals = findPluralsIds(ids, pluralsMaps)
        ids -= plurals

        val parametrized = ids.filter { en[it]!!.contains("$") }
        ids -= parametrized

        builder.append(sClassHeader)

        ids.sort()
        ids.forEach { appendStringMethod(it, en[it]!!, builder, false) }

        parametrized.sorted().forEach { appendParametrizedMethod(it, en[it]!!, builder, false) }
        pluralsMaps.keys.sorted().forEach { appendPluralMethod(it, pluralsMaps[it]!!, en, builder, false) }

        builder.append("}\n\n")
    }

    private fun appendLangClass(lang: String, map: HashMap<String, HashMap<String, String>>, builder: StringBuilder) {
        val langMap = map[lang]!!
        val enIds = ArrayList<String>(map["en"]!!.keys)
        val ids = ArrayList(langMap.keys).filter { enIds.contains(it) } as ArrayList

        val pluralsMaps = HashMap<String, ArrayList<String>>()
        val plurals = findPluralsIds(ids, pluralsMaps)
        ids -= plurals

        val parametrized = ids.filter { langMap[it]!!.contains("$") }
        ids -= parametrized


        builder.append("class $lang extends S {\n  const $lang();\n\n   " +
                "@override\n  TextDirection get textDirection => TextDirection.${if (rtl.contains(lang.split("_")[0])) "rtl" else "ltr"};\n\n")

        ids.forEach { appendStringMethod(it, langMap[it]!!, builder) }
        parametrized.forEach { appendParametrizedMethod(it, langMap[it]!!, builder) }
        pluralsMaps.keys.forEach { appendPluralMethod(it, pluralsMaps[it]!!, langMap, builder) }

        builder.append("}\n\n")

        //for hebrew iw=he
        if (lang.startsWith("iw")) {
            builder.append("class he_IL extends $lang {\n const he_IL();\n\n   " +
                    "@override\n  TextDirection get textDirection => TextDirection.rtl;\n\n}")
        }
    }

    private fun appendDelegateClass(map: HashMap<String, HashMap<String, String>>, builder: StringBuilder) {
        builder.append(delegateClassHeader)
        map.keys.forEach {
            val langParts = it.split("_")
            val lang = langParts[0]
            val country = if (langParts.size == 2) langParts[1] else ""


            //for hebrew iw=he
            if (it.startsWith("iw")) {
                builder.append("      const Locale(\"he\", \"IL\"),\n")
            } else builder.append("      const Locale(\"$lang\", \"$country\"),\n")
        }

        builder.append(delegateClassResolution)
        map.keys.forEach {
            //for hebrew iw=he
            if (it.startsWith("iw")) {
                builder.append("      case \"iw_IL\":\n      case \"he_IL\":        return new SynchronousFuture<WidgetsLocalizations>(const he_IL());\n")
            } else builder.append("      case \"$it\":\n        return new SynchronousFuture<WidgetsLocalizations>(const $it());\n")
        }

        builder.append(delegateClassEnd)
    }


    internal fun appendStringMethod(id: String, value: String, builder: StringBuilder, isOverride: Boolean = true) {
        if (isOverride) builder.append("  @override\n")
        builder.append("  String get $id => \"$value\";\n")
    }

    internal fun appendParametrizedMethod(id: String, value: String, builder: StringBuilder, isOverride: Boolean = true) {
        PARAMETER_MATCHER.reset(value)

        if (isOverride) builder.append("  @override\n")
        builder.append("  String $id(")
        while (PARAMETER_MATCHER.find()) {
            val parameter = PARAMETER_MATCHER.group().substring(1)
            builder.append("String $parameter, ")
        }
        builder.setLength(builder.length - 2)
        builder.append(") => \"$value\";\n")
    }

    internal fun appendPluralMethod(id: String, countsList: ArrayList<String>, valuesMap: HashMap<String, String>,
                                    builder: StringBuilder, isOverride: Boolean = true) {
        val zero = countsList.contains("Zero")
        val one = countsList.contains("One")
        val two = countsList.contains("Two")
        val few = countsList.contains("Few")
        val many = countsList.contains("Many")


        val parameterName: String = {
            PARAMETER_MATCHER.reset(valuesMap["${id}Other"]!!).find()
            PARAMETER_MATCHER.group().substring(1)
        }()

        if (isOverride) builder.append("  @override\n")
        builder.append("  String $id(String $parameterName) {\n    switch ($parameterName) {\n")

        if (zero) builder.append("      case \"0\":\n        return \"${valuesMap["${id}Zero"]!!}\";\n")
        if (one) builder.append("      case \"1\":\n        return \"${valuesMap["${id}One"]!!}\";\n")
        if (two) builder.append("      case \"2\":\n        return \"${valuesMap["${id}Two"]!!}\";\n")
        if (few) builder.append("      case \"few\":\n        return \"${valuesMap["${id}Few"]!!}\";\n")
        if (many) builder.append("      case \"many\":\n        return \"${valuesMap["${id}Many"]!!}\";\n")
        builder.append("      default:\n        return \"${valuesMap["${id}Other"]!!}\";\n    }\n  }\n")
    }

    fun getCountFromValue(text: String): String? = when (text) {
        "0" -> "Zero"
        "1" -> "One"
        "2" -> "Two"
        "few" -> "Few"
        "many" -> "Many"
        else -> throw IllegalArgumentException("This value $text is not valid.")
    }

    /**
     * Create a file in the values folder for the given language.
     */
    private fun createFileForLang(lang: String): VirtualFile {
        val virtualFile = valuesFolder.findOrCreateChildData(this, "strings_$lang.arb")
        val psiFile = psiManager.findFile(virtualFile)!! as JsonFile
        val doc = documentManager.getDocument(psiFile)!!
        doc.setText("{}")
        CodeStyleManager.getInstance(psiManager).reformat(psiFile)
        return virtualFile
    }

    /**
     * Searches for plurals in the ids of the strings and return a list will al of them.
     *
     * @param ids contains the list that needs to be searched for plurals
     * @param pluralsMaps we append to this map the id of the plural and a list of all the qualities("One", "Two", ...)
     * that were declared.
     *
     * @return A list with the ids that are considered plurals and that will be treated separately.
     *
     * NOTE: It is not considered a plural when the Other quantity is not declared. In this case the other qualities
     * will be treated as independent ids.
     */
    private fun findPluralsIds(ids: ArrayList<String>, pluralsMaps: HashMap<String, ArrayList<String>>): List<String> {
        val map = HashMap<String, ArrayList<String>>()
        val pluralIds = ids.filter {
            PLURAL_MATCHER.reset(it)
            val find = PLURAL_MATCHER.find()
            if (find) {
                val id = PLURAL_MATCHER.group(1)
                val quantity = PLURAL_MATCHER.group(2)
                val list = map[id] ?: ArrayList()
                list.add(quantity)
                map[id] = list
            }
            find
        } as ArrayList

        HashMap(map).forEach { id, counts ->
            if (counts.none { it == "Other" }) {
                counts.forEach { count -> pluralIds.remove("$id$count") }
                map.remove(id)
            }
        }

        pluralsMaps.putAll(map)
        return pluralIds
    }


    private fun getStringFromFile(file: PsiFile): HashMap<String, String>? {
        if (PsiTreeUtil.findChildOfType(file, PsiErrorElement::class.java) != null) return null
        val langMap = HashMap<String, String>()
        PsiTreeUtil.findChildrenOfType(file, JsonProperty::class.java).forEach {
            langMap[it.name] = it.value?.text!!.drop(1).dropLast(1)
        }
        return langMap
    }

    companion object {
        private val PLURAL_MATCHER = Pattern.compile("(.*)(Zero|One|Two|Few|Many|Other)").matcher("")
        private val PARAMETER_MATCHER = Pattern.compile("\\$[^\\p{Punct}\\p{Space}\\p{sc=Han}\\p{sc=Hiragana}\\p{sc=Katakana}–]*").matcher("")

// @formatter:off
private const val i18nFileImports =
"""
import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
"""

private const val sClassHeader =
"""
class S implements WidgetsLocalizations {
  const S();

  static const GeneratedLocalizationsDelegate delegate =
      const GeneratedLocalizationsDelegate();

  static S of(BuildContext context) =>
      Localizations.of<S>(context, WidgetsLocalizations);

  @override
  TextDirection get textDirection => TextDirection.ltr;

"""

private const val delegateClassHeader =
"""
class GeneratedLocalizationsDelegate extends LocalizationsDelegate<WidgetsLocalizations> {
  const GeneratedLocalizationsDelegate();

  List<Locale> get supportedLocales {
    return const <Locale>[

"""

private const val delegateClassResolution =
"""
    ];
  }

  LocaleResolutionCallback resolution({Locale fallback}) {
    return (Locale locale, Iterable<Locale> supported) {
      final Locale languageLocale = new Locale(locale.languageCode, "");
      if (supported.contains(locale))
        return locale;
      else if (supported.contains(languageLocale))
        return languageLocale;
      else {
        final Locale fallbackLocale = fallback ?? supported.first;
        return fallbackLocale;
      }
    };
  }

  @override
  Future<WidgetsLocalizations> load(Locale locale) {
    final String lang = getLang(locale);
    switch (lang) {

"""

private const val delegateClassEnd =
"""
      default:
        return new SynchronousFuture<WidgetsLocalizations>(const S());
    }
  }

  @override
  bool isSupported(Locale locale) => supportedLocales.contains(locale);

  @override
  bool shouldReload(GeneratedLocalizationsDelegate old) => false;
}

String getLang(Locale l) => l.countryCode != null && l.countryCode.isEmpty
    ? l.languageCode
    : l.toString();
"""
// @formatter:on

        private val rtl: Set<String> = setOf("ar", "dv", "fa", "ha", "he", "iw", "ji", "ps", "ur", "yi")
    }
}